(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{392:function(t,a,s){"use strict";s.r(a);var r=s(44),_=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"四次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四次握手"}},[t._v("#")]),t._v(" 四次握手")]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/img/http/four-hand.jpg",alt:"image"}})]),t._v(" "),s("p",[t._v("第一次挥手: 客户端 和 服务器 打电话，通话即将结束后   客户端处于 FIN_WAIT1 状态。")]),t._v(" "),s("p",[t._v("第二次挥手: 客户端说“我没啥要说的了”，服务器回答“我知道了”，但是 服务器 可能还会有要说的话  服务端处于 CLOSE_WAIT 状态\n客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态")]),t._v(" "),s("p",[t._v("第三次挥手: 客户端 不能要求 服务器 跟着自己的节奏结束通话，于是 服务器 可能又巴拉巴拉说了一通，最后 服务器 说“我说完了  服务端处于 LAST_ACK 的状态")]),t._v(" "),s("p",[t._v("第四次握手: 客户端 回答“知道了”，这样通话才算结束。  客户端处于 TIME_WAIT 状态 等待计时器设置的时间2MSL后，客户端才进入CLOSED状态     服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。服务端先关。")]),t._v(" "),s("h3",{attrs:{id:"tcp为什么要进行四次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp为什么要进行四次握手"}},[t._v("#")]),t._v(" TCP为什么要进行四次握手")]),t._v(" "),s("p",[t._v("因为数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。")]),t._v(" "),s("h3",{attrs:{id:"等待2msl的意义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#等待2msl的意义"}},[t._v("#")]),t._v(" 等待2MSL的意义")]),t._v(" "),s("p",[t._v("为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态\n总结：网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。")])])}),[],!1,null,null,null);a.default=_.exports}}]);