(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{431:function(t,e,a){"use strict";a.r(e);var n=a(44),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"合成事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合成事件"}},[t._v("#")]),t._v(" 合成事件")]),t._v(" "),a("h3",{attrs:{id:"动机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动机"}},[t._v("#")]),t._v(" 动机")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("抹平不同浏览器之间的兼容性差异。最主要的动机。")])]),t._v(" "),a("li",[a("p",[t._v('事件"合成"，即事件自定义。事件合成既可以处理兼容性问题，也可以用来自定义事件（例如 React 的 onChange 事件）。')])]),t._v(" "),a("li",[a("p",[t._v("提供一个抽象跨平台事件机制。类似 VirtualDOM 抽象了跨平台的渲染方式，合成事件（SyntheticEvent）提供一个抽象的跨平台事件机制。")])]),t._v(" "),a("li",[a("p",[t._v("可以做更多优化。例如利用事件委托机制，几乎所有事件的触发都代理到了 document，而不是 DOM 节点本身，简化了 DOM 事件处理逻辑，减少了内存开销。（React 自身模拟了一套事件冒泡的机制）")])]),t._v(" "),a("li",[a("p",[t._v("可以干预事件的分发。V16引入 Fiber 架构，React 可以通过干预事件的分发以优化用户的交互体验。")])])]),t._v(" "),a("p",[t._v("注：「几乎」所有事件都代理到了 document，说明有例外，比如audio、video标签的一些媒体事件（如 onplay、onpause 等），是 document 所不具有，这些事件只能够在这些标签上进行事件进行代理，但依旧用统一的入口分发函数（dispatchEvent）进行绑定。")]),t._v(" "),a("h3",{attrs:{id:"事件注册"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件注册"}},[t._v("#")]),t._v(" 事件注册")]),t._v(" "),a("p",[t._v("React 的事件注册过程主要做了两件事：document 上注册、存储事件回调。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/img/react/SyntheticEvent01.png",alt:"image"}})]),t._v(" "),a("ol",[a("li",[a("p",[t._v("document 上注册")]),t._v(" "),a("p",[t._v("在 React 组件挂载阶段，根据组件内的声明的事件类型（onclick、onchange 等），在 document 上注册事件（使用addEventListener），并指定统一的回调函数 dispatchEvent。换句话说，document 上不管注册的是什么事件，都具有统一的回调函数 dispatchEvent。也正是因为这一事件委托机制，具有同样的回调函数 dispatchEvent，所以对于同一种事件类型，不论在 document 上注册了几次，最终也只会保留一个有效实例，这能减少内存开销。")])]),t._v(" "),a("li",[a("p",[t._v("存储事件回调")]),t._v(" "),a("p",[t._v("React 为了在触发事件时可以查找到对应的回调去执行，会把组件内的所有事件统一地存放到一个对象中（listenerBank）。而存储方式如上图，首先会根据事件类型分类存储，例如 click 事件相关的统一存储在一个对象中，回调函数的存储采用键值对（key/value）的方式存储在对象中，key 是组件的唯一标识 id，value 对应的就是事件的回调函数。")])])]),t._v(" "),a("p",[t._v("React 的事件注册的关键步骤如下图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/img/react/SyntheticEvent02.png",alt:"image"}})]),t._v(" "),a("h3",{attrs:{id:"事件分发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件分发"}},[t._v("#")]),t._v(" 事件分发")]),t._v(" "),a("p",[t._v("事件分发也就是事件触发。React 的事件触发只会发生在 DOM 事件流的冒泡阶段，因为在 document 上注册时就默认是在冒泡阶段被触发执行。")]),t._v(" "),a("p",[t._v("其大致流程如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1. 触发事件，开始 DOM 事件流，先后经过三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段\n2. 当事件冒泡到 document 时，触发统一的事件分发函数 ReactEventListener.dispatchEvent\n3. 根据原生事件对象（nativeEvent）找到当前节点（即事件触发节点）对应的 ReactDOMComponent 对象\n4. 事件的合成\n\ta. 根据当前事件类型生成对应的合成对象\n\tb. 封装原生事件对象和冒泡机制\n\tc. 查找当前元素以及它所有父级\n\td. 在 listenerBank 中查找事件回调函数并合成到 events 中\n5. 批量执行合成事件（events）内的回调函数\n6. 如果没有阻止冒泡，会将继续进行 DOM 事件流的冒泡（从 document 到 window），否则结束事件触发\n")])])]),a("p",[a("img",{attrs:{src:"/assets/img/react/SyntheticEvent03.png",alt:"image"}})]),t._v(" "),a("p",[t._v("注：上图中阻止冒泡是指调用stopImmediatePropagation 方法阻止冒泡，如果是调用stopPropagation阻止冒泡，document 上如果还注册了同类型其他的事件，也将会被触发执行，但会正常阻断 window 上事件触发。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/img/react/SyntheticEvent04.png",alt:"image"}})]),t._v(" "),a("p",[t._v("点击 child div 时，其输出如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/img/react/SyntheticEvent05.png",alt:"image"}})])])}),[],!1,null,null,null);e.default=s.exports}}]);