(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{474:function(e,t,v){"use strict";v.r(t);var _=v(44),r=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"vue3-设计思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue3-设计思想"}},[e._v("#")]),e._v(" Vue3 设计思想")]),e._v(" "),v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#_1-vue3-设计目标"}},[e._v("1. Vue3 设计目标")]),v("ul",[v("li",[v("a",{attrs:{href:"#_1-1-更快-proxy"}},[e._v("1.1 更快 - Proxy")])]),v("li",[v("a",{attrs:{href:"#_1-2-更快-virtual-dom-重构"}},[e._v("1.2 更快 - Virtual Dom 重构")])]),v("li",[v("a",{attrs:{href:"#_1-3-更快-更多编译优化"}},[e._v("1.3 更快 - 更多编译优化")])])])]),v("li",[v("a",{attrs:{href:"#_2-vue-设计思考"}},[e._v("2. Vue 设计思考")]),v("ul",[v("li",[v("a",{attrs:{href:"#_2-1-scope"}},[e._v("2.1 Scope")])]),v("li",[v("a",{attrs:{href:"#_2-2-jsx-vs-template"}},[e._v("2.2 JSX vs Template")])])])]),v("li",[v("a",{attrs:{href:"#_3-参考"}},[e._v("3. 参考")])])])]),v("p"),e._v(" "),v("h2",{attrs:{id:"_1-vue3-设计目标"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue3-设计目标"}},[e._v("#")]),e._v(" 1. Vue3 设计目标")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("更小 -> tree shaking")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("更快")])]),e._v(" "),v("ol",[v("li",[e._v("Object.defineProperty -> Proxy(使得初始化不用再递归data)")]),e._v(" "),v("li",[e._v("Virtual Dom 重构 -> 利用模板代码，确定动态和静态代码，在VDom Diff时优化\n"),v("ul",[v("li",[e._v("可跳过静态文本（无需递归进入子树循环），可跳过props对比 (patchs flag)")]),e._v(" "),v("li",[e._v("事件监听函数cache (Cache Handlers)")]),e._v(" "),v("li",[e._v("SSR  创建静态的标签直接使用字符串式，push进buffer流内，而不用一个一个去createElement")]),e._v(" "),v("li",[e._v("当静态节点嵌套得特别深入，也会创建出一个staticNode去优化")])])]),e._v(" "),v("li",[e._v("更多编译优化 -> 利用模板代码，尽可能预先优化编译的代码\n"),v("ul",[v("li",[e._v("slot默认编译为函数（不存在父子组件强耦合）")]),e._v(" "),v("li",[e._v("Momomorphic vnode factory")]),e._v(" "),v("li",[e._v("Compiler-generated flags for vnode/children types（VNode带上类型）")])])])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("加强TypeScript支持")])]),e._v(" "),v("ol",[v("li",[e._v("用不用 TS 都可以享受参数提示 类型声明")]),e._v(" "),v("li",[e._v("可以用插件做"),v("code",[e._v("模板")]),e._v("的 参数提示 类型检查")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("Composition(组合) API")])]),e._v(" "),v("ul",[v("li",[e._v("注重逻辑复用")])])]),e._v(" "),v("li",[v("p",[e._v("加强API设计一致性")])]),e._v(" "),v("li",[v("p",[e._v("提高自身可维护性")])]),e._v(" "),v("li",[v("p",[e._v("开放更多底层功能")]),e._v(" "),v("ul",[v("li",[e._v("响应式数据监听（即Vue2.x的Object.observer）")])])])]),e._v(" "),v("h3",{attrs:{id:"_1-1-更快-proxy"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-更快-proxy"}},[e._v("#")]),e._v(" 1.1 更快 - Proxy")]),e._v(" "),v("p",[v("strong",[e._v("Proxy减少了组件实例初始化开销")]),e._v("。在Vue2中，"),v("code",[e._v("初始化组件时")]),e._v("会对data的属性递归调用包装（Object.defineProperty）;而在Vue3中，初始化只是书写Proxy的代理handler（Proxy包装），当"),v("code",[e._v("运行时")]),e._v("getter某个属性时，才去重新Proxy包装该值，减少了初始化组件的时间。"),v("RouterLink",{attrs:{to:"/vue/vue3-reactive.html#_2-reactive"}},[e._v("Vue3 响应式原理")])],1),e._v(" "),v("p",[e._v("ES6 Proxy数据监听优点：")]),e._v(" "),v("ol",[v("li",[e._v("对对象进行直接监听, 可以"),v("code",[e._v("弥补Object.defineProperty无法监听新增删除属性的短板")])]),e._v(" "),v("li",[v("code",[e._v("无需再遍历对象进行设置")]),e._v("监听函数Object.defineProperty")]),e._v(" "),v("li",[e._v("可以"),v("code",[e._v("适用于Array")]),e._v(", 不需要再分成两种写法")])]),e._v(" "),v("h3",{attrs:{id:"_1-2-更快-virtual-dom-重构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-更快-virtual-dom-重构"}},[e._v("#")]),e._v(" 1.2 更快 - Virtual Dom 重构")]),e._v(" "),v("p",[v("code",[e._v("VDOM作用, 状态（或者叫数据）驱动UI，开发者只考虑状态改变，而UI会自动变化，这就是VDOM的最大价值。")]),e._v("所以在VDOM基础上，UI不仅可以是DOM元素（web端），也可以是Native（移动端）。")]),e._v(" "),v("h4",{attrs:{id:"传统virtual-dom的性能瓶颈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#传统virtual-dom的性能瓶颈"}},[e._v("#")]),e._v(" 传统Virtual DOM的性能瓶颈")]),e._v(" "),v("p",[e._v("数据变更之后，新的Virtual DOM和旧的Virtual DOM进行 patch 算法比较，并算出二者之间的差异，将差异进行修改。但是传统Virtual DOM，进行算法比对时颗粒度是组件，每个组件作为一个颗粒。\n虽然Vue能够保证触发更新的组件最小化，但是单个组件内部依然需要遍历该组件的整个Virtual DOM树。")]),e._v(" "),v("p",[v("img",{attrs:{src:"/assets/img/vue/vue2-diffqd.png",alt:"image"}})]),e._v(" "),v("p",[v("code",[e._v("传统Virtual DOM的性能跟模板大小正相关，跟动态节点的数量无关")]),e._v("。模板或者组件有多大，那么在进行数据更新时损耗的性能就有多大，但实际上，这种方式利用率很低。如上图所示，在上述template中，发生改变的地方只有message插值的部分，整体结构不变，但是"),v("code",[e._v("数据更新的时候，比对整个template结构，这样就存在性能损耗")]),e._v("。\n所以"),v("code",[e._v("在一些组件整个模板内只有少量动态节点的情况下，传统方法遍历存在性能的浪费")]),e._v("。")]),e._v(" "),v("h4",{attrs:{id:"vue3-0-virtual-dom"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0-virtual-dom"}},[e._v("#")]),e._v(" Vue3.0 Virtual DOM")]),e._v(" "),v("p",[v("code",[e._v("动静结合")]),e._v("，找到动态变化的部分，更新时只对比可以变化的部分，减少性能损耗。")]),e._v(" "),v("p",[v("code",[e._v("实现上，就是在模板编译时，给各个VNode带上type类型，区分不同的变更需求，然后在VDOM时对不同type的VNode更新做优化处理")]),e._v("。")]),e._v(" "),v("h3",{attrs:{id:"_1-3-更快-更多编译优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-更快-更多编译优化"}},[e._v("#")]),e._v(" 1.3 更快 - 更多编译优化")]),e._v(" "),v("p",[e._v("主要是利用模板代码的可预见性，在编译时做好编译优化")]),e._v(" "),v("ul",[v("li",[e._v("优化slots生成。slot编译时统一为函数（v-slot），父子组件slot渲染分离。")]),e._v(" "),v("li",[e._v("静态内容提取。模板不变时，diff跳过（Vue2已优化）")]),e._v(" "),v("li",[e._v("静态属性提取")]),e._v(" "),v("li",[e._v("内联函数提取")]),e._v(" "),v("li",[e._v("Fragement\n"),v("ul",[v("li",[e._v("vue 2.0 模板只有一个根节点，在vue3里面无需拥有根节点，可以多行文字，多个节点，vue3会自动变成一个碎片。而如果用户使用渲染函数，也可以直接在渲染函数中返回一个数组，自动变为碎片")])])]),e._v(" "),v("li",[e._v("Teleport\n"),v("ul",[v("li",[e._v("类似于React portal   接受一个disbaled参数，将本来应该传送出去的东西驳斥回来，放在原来的渲染函数里面，disalbed 用于响应式的设计，比如宽的屏幕展示出来，窄的屏幕拉回来。\nSuspense")]),e._v(" "),v("li",[e._v("它可以在嵌套的组件树渲染到屏幕上之前，可以在内存里面进行渲染，可以检测整颗树里面的异步依赖，只有当将整颗树的异步依赖都渲染完成之后，也就是resolve之后，才会将组件树渲染到屏幕上去。")]),e._v(" "),v("li",[e._v("管理嵌套组件的异步加载")])])])]),e._v(" "),v("h2",{attrs:{id:"_2-vue-设计思考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue-设计思考"}},[e._v("#")]),e._v(" 2. Vue 设计思考")]),e._v(" "),v("h3",{attrs:{id:"_2-1-scope"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-scope"}},[e._v("#")]),e._v(" 2.1 Scope")]),e._v(" "),v("p",[e._v("框架职责，React主要聚合在底层，不会像Angular一样大包大揽，拥有Route、Form解决方案等。")]),e._v(" "),v("ol",[v("li",[e._v("Scope小\n"),v("ul",[v("li",[e._v("优点：只关注底层，不用再维护额外的解决方案，都丢给社区。上手快，因为记忆小。")]),e._v(" "),v("li",[e._v("缺点：解决方案分散（另一个维度，造就社区繁荣）")])])])]),e._v(" "),v("h3",{attrs:{id:"_2-2-jsx-vs-template"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-jsx-vs-template"}},[e._v("#")]),e._v(" 2.2 JSX vs Template")]),e._v(" "),v("ol",[v("li",[e._v("JSX：\n"),v("ul",[v("li",[e._v("优点：完整的JS表达能力、视图即数据")]),e._v(" "),v("li",[e._v("缺点：VDOM难以优化，因为js动态性，无法预先优化")])])]),e._v(" "),v("li",[e._v("Template\n"),v("ul",[v("li",[e._v("优点：可以预先优化VDOM")])])])]),e._v(" "),v("h2",{attrs:{id:"_3-参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-参考"}},[e._v("#")]),e._v(" 3. 参考")]),e._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://www.bilibili.com/video/av56093550?from=search&seid=17425026665332701435",target:"_blank",rel:"noopener noreferrer"}},[e._v("VueConf 2019-上海演讲视频"),v("OutboundLink")],1)]),e._v(" "),v("li",[v("a",{attrs:{href:"https://www.bilibili.com/video/av48968552?from=search&seid=11269305592002355043",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue 3.0 进展@VueConf CN 2018"),v("OutboundLink")],1)]),e._v(" "),v("li",[v("a",{attrs:{href:"https://www.bilibili.com/video/av80042358?from=search&seid=17425026665332701435",target:"_blank",rel:"noopener noreferrer"}},[e._v("在框架设计中寻求平衡"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=r.exports}}]);