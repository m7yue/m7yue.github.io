(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{432:function(t,s,a){"use strict";a.r(s);var n=a(44),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-diff-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-diff-算法"}},[t._v("#")]),t._v(" react Diff 算法")]),t._v(" "),a("h3",{attrs:{id:"虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),a("p",[t._v("就是一个 js 对象： 两个真实 dom 的比对非常耗费性能，因为真实dom上携带了很多对比对过程中不必要的东西。其实就是这么简单。")]),t._v(" "),a("h3",{attrs:{id:"key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#key"}},[t._v("#")]),t._v(" key")]),t._v(" "),a("p",[t._v("如果 key 值相同的话，我这个 DOM 就可以直接复用了，就不用再创建 DOM 了。另外，如果 key 值相同，那么我就直接比较就可以了，不用再循环比对了。")]),t._v(" "),a("h3",{attrs:{id:"diff"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff"}},[t._v("#")]),t._v(" diff")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("两个原则")]),t._v(" "),a("ul",[a("li",[t._v("对比当前真实的DOM和虚拟DOM，在对比过程中直接更新真实DOM")]),t._v(" "),a("li",[t._v("只对比同一层级的变化")])])]),t._v(" "),a("li",[a("p",[t._v("diff策略")]),t._v(" "),a("ul",[a("li",[t._v("Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。")]),t._v(" "),a("li",[t._v("拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。")]),t._v(" "),a("li",[t._v("对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。")])])]),t._v(" "),a("li",[a("p",[t._v("虚拟DOM")]),t._v(" "),a("ul",[a("li",[t._v("document.createDocumentFragment 的使用")])])]),t._v(" "),a("li",[a("p",[t._v("过程")]),t._v(" "),a("ul",[a("li",[t._v("先序深度优先遍历对每个节点进行标号（这个标号以旧节点为参照）")]),t._v(" "),a("li",[t._v("根据标号对比新旧两个虚拟 DOM 的区别，获取补丁对象\n"),a("ul",[a("li",[t._v("获取到的补丁对象形如")])])])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" patches "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("type"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ATTR"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("attr"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"list-group"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 属性更改")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("type"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"REMOVE"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("index"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 节点删除")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("type"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"REPLACE"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("newNode"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("newNode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 节点更新  相当于删除、新增")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("type"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"TEXT"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("text"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"修改的文本"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 文本更新 ")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("ul",[a("li",[t._v("根据节点标号所对应的补丁对象及补丁类型进行不同更新 DOM 操作")])])]),t._v(" "),a("li",[a("p",[t._v("key 的策略")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/img/react/react-diff-key.png",alt:"image"}})]),t._v(" "),a("ul",[a("li",[t._v("看着上图的 B，React先从新中取得B，然后判断旧中是否存在相同节点B，当发现存在节点B后，就去判断是否移动B。B在旧 中的index=1，它的lastIndex=0，不满足 index < lastIndex 的条件，因此 B 不做移动操作。此时，一个操作是，lastIndex=(index,lastIndex)中的较大数=1.")]),t._v(" "),a("li",[t._v("看着 A，A在旧的index=0，此时的lastIndex=1，满足index<lastIndex，对A进行移动操作，此时lastIndex=max(index,lastIndex)=1。")]),t._v(" "),a("li",[t._v("看着D，同（1），不移动，由于D在旧的index=3，比较时，lastIndex=1，所以改变lastIndex=max(index,lastIndex)=3")]),t._v(" "),a("li",[t._v("看着C，同（2），移动，C在旧的index=2，满足index<lastIndex（lastIndex=3），所以移动。")])]),t._v(" "),a("p",[t._v("fiber 下的 diff")]),t._v(" "),a("p",[t._v("第一轮遍历：处理更新的节点。\n第二轮遍历：处理剩下的不属于更新的节点。")]),t._v(" "),a("p",[t._v("第一轮遍历步骤如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1. let i = 0，遍历newChildren，将newChildren[i]与oldFiber比较，判断DOM节点是否可复用。\n2. 如果可复用，i++，继续比较newChildren[i]与oldFiber.sibling，可以复用则继续遍历。\n3. 如果不可复用，分两种情况：\n\ta. key不同导致不可复用，立即跳出整个遍历，第一轮遍历结束。\n\tb. key相同type不同导致不可复用，会将oldFiber标记为DELETION，并继续遍历\n4. 如果newChildren遍历完（即i === newChildren.length - 1）或者oldFiber遍历完（即oldFiber.sibling === null），跳出遍历，第一轮遍历结束。\n")])])]),a("p",[t._v("第二轮遍历\n对于第一轮遍历的结果，我们分别讨论：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1. newChildren与oldFiber同时遍历完\n那就是最理想的情况：只需在第一轮遍历进行组件更新。此时Diff结束。\n\n2. newChildren没遍历完，oldFiber遍历完\n已有的DOM节点都复用了，这时还有新加入的节点，意味着本次更新有新节点插入，我们只需要遍历剩下的newChildren为生成的workInProgress fiber依次标记Placement。\n\n\n3. newChildren遍历完，oldFiber没遍历完\n意味着本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的oldFiber，依次标记Deletion。\n\n4. newChildren与oldFiber都没遍历完\n")])])]),a("p",[t._v("剩下的就是循环新数组，找到 Map 里面可以复用的节点，如果找不到就创建")])])}),[],!1,null,null,null);s.default=e.exports}}]);