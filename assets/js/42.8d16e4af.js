(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{402:function(t,a,s){"use strict";s.r(a);var v=s(44),r=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"三次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/img/http/three-hand.jpg",alt:"image"}})]),t._v(" "),s("p",[t._v("第一次握手: 发送"),s("em",[t._v("SYN")]),t._v("报文，传达信息：“你好，我想建立连接”")]),t._v(" "),s("p",[t._v("第二次握手: 回传SYN+ACK报文，传达信息：“好的，可以建立链接”；")]),t._v(" "),s("p",[t._v("第三次握手: 回传ACK报文，传到信息：“好的，我知道了，那我们连接”。然后就建立连接了")]),t._v(" "),s("h3",{attrs:{id:"tcp为什么要进行三次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp为什么要进行三次握手"}},[t._v("#")]),t._v(" TCP为什么要进行三次握手：")]),t._v(" "),s("p",[t._v("因为网络传输有延迟，客户端发送请求到服务器端要求建立连接，如果服务器端直接返回的话可能会产生丢包的情况导致客户端接收不到数据，客户端会因为超时就关闭了，可能就去发送新的请求了，然而服务端并不知道丢包导致客户端没有接收数据，服务端端口就一直开着，造成了额外的开销。所以需要三次握手确认这个过程。\n同时也需要三次握手才能确认双方的接收与发送能力是否正常。")]),t._v(" "),s("h3",{attrs:{id:"半连接队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#半连接队列"}},[t._v("#")]),t._v(" 半连接队列")]),t._v(" "),s("p",[t._v("服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。")]),t._v(" "),s("h3",{attrs:{id:"全连接队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全连接队列"}},[t._v("#")]),t._v(" 全连接队列")]),t._v(" "),s("p",[t._v("就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。")]),t._v(" "),s("h3",{attrs:{id:"syn-ack-重传次数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#syn-ack-重传次数"}},[t._v("#")]),t._v(" SYN-ACK 重传次数")]),t._v(" "),s("p",[t._v("服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户端确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......")]),t._v(" "),s("h3",{attrs:{id:"三次握手过程中可以携带数据吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三次握手过程中可以携带数据吗"}},[t._v("#")]),t._v(" 三次握手过程中可以携带数据吗")]),t._v(" "),s("p",[t._v("第一次、第二次握手不可以携带数据。假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。")]),t._v(" "),s("p",[t._v("对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。")]),t._v(" "),s("h3",{attrs:{id:"syn攻击是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#syn攻击是什么"}},[t._v("#")]),t._v(" SYN攻击是什么")]),t._v(" "),s("p",[t._v("服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。")]),t._v(" "),s("p",[t._v("常见的防御 SYN 攻击的方法有如下几种：")]),t._v(" "),s("ul",[s("li",[t._v("缩短超时（SYN Timeout）时间")]),t._v(" "),s("li",[t._v("增加最大半连接数")]),t._v(" "),s("li",[t._v("过滤网关防护")]),t._v(" "),s("li",[t._v("SYN cookies技术")])])])}),[],!1,null,null,null);a.default=r.exports}}]);