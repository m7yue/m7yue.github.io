(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{468:function(t,e,a){"use strict";a.r(e);var r=a(44),l=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"计算属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算属性"}},[t._v("#")]),t._v(" 计算属性")]),t._v(" "),a("p",[t._v("源码逻辑：")]),t._v(" "),a("p",[t._v("初始化阶段：\n创建每一个计算属性对应的 watcher , dirty 为true, 将计算属性定义到实例上， 就可通过this.xxx 获取。\n同时会对计算方法做一层包装：根据 dirty 判断是执行方法还是返回缓存值 （watcher.value）")]),t._v(" "),a("p",[t._v("第一次获取计算属性值：")]),t._v(" "),a("ol",[a("li",[t._v("会执行 watcher 的 evaluate 方法 , 这个 evalute 就是执行了计算方法 然后更新 watcher 的 value。并且设置了dirty 为 false")]),t._v(" "),a("li",[t._v("重点： 在执行计算方法的时候， 会触发每一个依赖的响应数据的 get 而此时 Dep.target 就是当前计算属性对应的watcher,\n依赖的响应数据 会 将当前的watcher 放入自己管理的订阅器中（依赖收集）。")]),t._v(" "),a("li",[t._v("这样当某个依赖的响应数据变更的时候，触发订阅器发布更新，会执行上面 watcher 的 update方法，这个update方法知道这是个计算属性的\nwatcher  就干了一件事， 把dirty 设为 true")])]),t._v(" "),a("p",[t._v("第二次获取计算属性值：\n如果依赖的相应数据有变更，那么 watcher.dirty=true，会执行计算方法获取新值，否则获取到缓存的 watcher.value。")])])}),[],!1,null,null,null);e.default=l.exports}}]);