(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{427:function(e,n,a){"use strict";a.r(n);var t=a(44),r=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("大多数编译器可以分成三个阶段：解析（Parsing），转换（Transformation）以及代码生成（Code Generation）")]),e._v(" "),a("ol",[a("li",[e._v("解析是将最初原始的代码转换为一种更加抽象的表示（译者注：即AST）。")]),e._v(" "),a("li",[e._v("转换将对这个抽象的表示做一些处理，让它能做到编译器期望它做到的事情。")]),e._v(" "),a("li",[e._v("代码生成接收处理之后的代码表示，然后把它转换成新的代码。")])]),e._v(" "),a("h4",{attrs:{id:"解析-parsing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解析-parsing"}},[e._v("#")]),e._v(" 解析（Parsing）")]),e._v(" "),a("p",[e._v("解析一般来说会分成两个阶段：词法分析（Lexical Analysis）和语法分析（Syntactic Analysis）。")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("词法分析接收原始代码，然后把它分割成一些被称为 Token 的东西，这个过程是在词法分析\n器（Tokenizer或者Lexer）中完成的。")]),e._v(" "),a("p",[e._v("Token 是一个数组，由一些代码语句的碎片组成。它们可以是数字、标签、标点符号、运算符，\n或者其它任何东西。")])]),e._v(" "),a("li",[a("p",[e._v("语法分析 接收之前生成的 Token，把它们转换成一种抽象的表示，这种抽象的表示描述了代\n码语句中的每一个片段以及它们之间的关系。这被称为中间表示（intermediate representation）或抽象语法树（Abstract Syntax Tree， 缩写为AST）")]),e._v(" "),a("p",[e._v("抽象语法树是一个嵌套程度很深的对象，用一种更容易处理的方式代表了代码本身，也能给我们\n更多信息。")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  比如说对于下面这一行代码语句：\n \n    (add 2 (subtract 4 2))\n \n  它产生的 Token 看起来或许是这样的：\n \n    [\n      { type: 'paren',  value: '('        },\n      { type: 'name',   value: 'add'      },\n      { type: 'number', value: '2'        },\n      { type: 'paren',  value: '('        },\n      { type: 'name',   value: 'subtract' },\n      { type: 'number', value: '4'        },\n      { type: 'number', value: '2'        },\n      { type: 'paren',  value: ')'        },\n      { type: 'paren',  value: ')'        }\n    ]\n \n  它的抽象语法树（AST）看起来或许是这样的：\n \n    {\n      type: 'Program',\n      body: [{\n        type: 'CallExpression',\n        name: 'add',\n        params: [{\n          type: 'NumberLiteral',\n          value: '2'\n        }, {\n          type: 'CallExpression',\n          name: 'subtract',\n          params: [{\n            type: 'NumberLiteral',\n            value: '4'\n          }, {\n            type: 'NumberLiteral',\n            value: '2'\n          }]\n        }]\n      }]\n    }\n /\n")])])]),a("h4",{attrs:{id:"转换-transformation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#转换-transformation"}},[e._v("#")]),e._v(" 转换（Transformation）")]),e._v(" "),a("p",[e._v("它只是把 AST 拿过来然后对它做一些修改。它可以在同种语言下操作 AST，也可以把 AST 翻译成全新的语言。")]),e._v(" "),a("h4",{attrs:{id:"代码生成-code-generation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码生成-code-generation"}},[e._v("#")]),e._v(" 代码生成（Code Generation）")]),e._v(" "),a("p",[e._v("根据 AST 来输出代码.")]),e._v(" "),a("h4",{attrs:{id:"过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过程"}},[e._v("#")]),e._v(" 过程")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" 1. input  => tokenizer   => tokens\n 2. tokens => parser      => ast\n 3. ast    => transformer => newAst\n 4. newAst => generator   => output\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);