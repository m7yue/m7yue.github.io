(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{433:function(e,l,a){"use strict";a.r(l);var t=a(44),i=Object(t.a)({},(function(){var e=this,l=e.$createElement,a=e._self._c||l;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"react-fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber"}},[e._v("#")]),e._v(" react fiber")]),e._v(" "),a("p",[e._v("JavaScript 引擎和渲染引擎在同一个渲染线程， GUI 渲染和 JavaScript 执行两者是互斥的")]),e._v(" "),a("h3",{attrs:{id:"requestidlecallback"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#requestidlecallback"}},[e._v("#")]),e._v(" requestIdleCallback")]),e._v(" "),a("p",[e._v("总的来讲，通常，客户端线程执行任务时会以帧的形式划分，大部分设备控制在30-60帧是不会影响用户体验；在两个执行帧之间，主线程通常会有一小段空闲时间，requestIdleCallback可以在这个空闲期（Idle Period）调用空闲期回调（Idle Callback），执行一些任务。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("requestIdleCallback的第一个参数是callback")]),e._v(" "),a("ul",[a("li",[e._v("当callback被调用时，回接受一个参数 deadline，deadline是一个对象，对象上有两个属性\n"),a("ul",[a("li",[e._v("timeRemaining：timeRemaining属性是一个函数，函数的返回值表示当前空闲时间还剩下多少时间")]),e._v(" "),a("li",[e._v("didTimeout：didTimeout属性是一个布尔值，如果didTimeout是true，那么表示本次callback的执行是因为超时的原因")])])])])]),e._v(" "),a("li",[a("p",[e._v("requestIdleCallback的第二个参数是options\n* options是一个对象，可以用来配置超时时间 timeout")]),e._v(" "),a("ul",[a("li",[e._v("如果指定了timeout，但是浏览器没有在timeout指定的时间内执行callback。在下次空闲时间时，callback会强制执行。并且callback的参数，deadline.didTimeout等于true, deadline.timeRemaining()返回0。")])])]),e._v(" "),a("li",[a("p",[e._v("使用requestIdleCallback延迟数据的上报，可以避免一些渲染阻塞。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("如果使用了requestIdleCallback：")]),e._v(" "),a("p",[e._v("监听事件处理 --\x3e 页面渲染 --\x3e 数据上报（空闲时） --\x3e 监听事件处理 --\x3e 页面渲染 --\x3e 数据上报（空闲时）")])]),e._v(" "),a("li",[a("p",[e._v("如果不使用requestIdleCallback：")])])]),e._v(" "),a("p",[e._v("监听事件处理 --\x3e 数据上报（被添加到主线程中） --\x3e 监听事件处理 --\x3e 数据上报（被添加到主线程中） --\x3e 监听事件处理 --\x3e 数据上报（被添加到主线程中） --\x3e 页面渲染")])])]),e._v(" "),a("h3",{attrs:{id:"render阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render阶段"}},[e._v("#")]),e._v(" render阶段")]),e._v(" "),a("ul",[a("li",[e._v("可以对任务进行拆分，拆分的维度是虚拟DOM，此阶段可以暂停")]),e._v(" "),a("li",[e._v("两个任务：1.根据虚拟DOM生成fiber树  2.收集effectList")])]),e._v(" "),a("h3",{attrs:{id:"双缓冲机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双缓冲机制"}},[e._v("#")]),e._v(" 双缓冲机制")]),e._v(" "),a("ul",[a("li",[e._v("假设性优化")]),e._v(" "),a("li",[e._v("能够复用内部对象（fiber），节省内存分配、GC的时间开销。")])]),e._v(" "),a("h3",{attrs:{id:"任务优先级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任务优先级"}},[e._v("#")]),e._v(" 任务优先级")]),e._v(" "),a("p",[e._v("为了避免任务被饿死，可以设置一个超时时间. 这个超时时间不是死的，低优先级的可以慢慢等待, 高优先级的任务应该率先被执行. 目前 React 预定义了 5 个优先级。")]),e._v(" "),a("ul",[a("li",[e._v("Immediate(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断")]),e._v(" "),a("li",[e._v("UserBlocking(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈")]),e._v(" "),a("li",[e._v("Normal (5s) 应对哪些不需要立即感受到的任务，例如网络请求")]),e._v(" "),a("li",[e._v("Low (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知")]),e._v(" "),a("li",[e._v("Idle (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死")])]),e._v(" "),a("h3",{attrs:{id:"stack-reconciler-vs-fiber-reconciler"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#stack-reconciler-vs-fiber-reconciler"}},[e._v("#")]),e._v(" Stack reconciler Vs fiber reconciler")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Stack reconciler")]),e._v(" "),a("p",[e._v("将所有的Virtual DOM遍历完成后，reconciler才能给出当前需要修改真实DOM的信息，并传递给renderer，进行渲染，然后屏幕上才会显示此次更新内容。对于特别庞大的vDOM树来说，reconciliation过程会很长(x00ms)，在这期间，主线程是被js占用的，因此任何交互、布局、渲染都会停止，给用户的感觉就是页面被卡住了。")])]),e._v(" "),a("li",[a("p",[e._v("fiber reconciler")]),e._v(" "),a("ul",[a("li",[e._v("对于每个节点来说，其不光存储了对应元素的基本信息，还要保存一些用于任务调度的信息。")]),e._v(" "),a("li",[e._v("整个结构是一个链表树。每个工作单元（fiber）执行完成后，都会查看是否还继续拥有主线程时间片，如果有继续下一个，如果没有则先处理其他高优先级事务，等主线程空闲下来继续执行。\n"),a("ul",[a("li",[e._v("低优先级任务由requestIdleCallback处理；")]),e._v(" "),a("li",[e._v("高优先级任务，如动画相关的由requestAnimationFrame处理；")]),e._v(" "),a("li",[e._v("requestIdleCallback可以在多个空闲期调用空闲期回调，执行任务；")]),e._v(" "),a("li",[e._v("requestIdleCallback方法提供deadline，即任务执行限制时间，以切分任务，避免长时间执行，阻塞UI渲染而导致掉帧；")])])])])])]),e._v(" "),a("h3",{attrs:{id:"为什么需要新的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要新的生命周期"}},[e._v("#")]),e._v(" 为什么需要新的生命周期")]),e._v(" "),a("ul",[a("li",[e._v("因为新的react引入了异步渲染机制，主要的功能是，在渲染完成前，可以中断任务，中断之后不会继续执行生命周期，而是重头开始执行生命周期。这导致上述的componentWillMount，componentWillReceiveProps，componentWillUpdate可能会被中断，导致执行多次，带来意想不到的情况。\n"),a("ul",[a("li",[e._v("使用getDerivedStateFromProps配合componentDidUpdate可以替代componentWillReceiveProps的所有功能")]),e._v(" "),a("li",[e._v("使用getSnapshotBeforeUpdate和componentDidUpdate替代componentWillUpdate")])])])])])}),[],!1,null,null,null);l.default=i.exports}}]);